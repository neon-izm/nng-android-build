name: Build NNG Shared Library for Android

on:
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Version tag to checkout (e.g., v1.5.2)'
        required: false
        default: ''

env:
  # ===========================================
  # Build Configuration - Update these as needed
  # ===========================================
  # NNG Version
  NNG_VERSION: 'v1.11'

  # Android NDK Version
  # See: https://developer.android.com/ndk/downloads
  ANDROID_NDK_VERSION: 'r28c'

  # Android Minimum API Level
  # Android 5.0 = 21, Android 7.0 = 24, Android 8.0 = 26
  ANDROID_MIN_SDK: '23'

  # CMake Version (should match Android SDK CMake)
  CMAKE_VERSION: '3.31.5'

  # Java Version for Android builds
  JAVA_VERSION: '17'

  # Android STL
  ANDROID_STL: 'c++_static'

jobs:
  build-android-shared:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        android_abi: [arm64-v8a, armeabi-v7a, x86_64, x86]

    steps:
    - name: Checkout NNG repository
      uses: actions/checkout@v4
      with:
        repository: nanomsg/nng
        ref: ${{ github.event.inputs.version_tag || env.NNG_VERSION }}

    - name: Checkout this repository (for JNI files)
      uses: actions/checkout@v4
      with:
        path: jni-source

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: ${{ env.JAVA_VERSION }}

    - name: Setup CMake
      uses: jwlawson/actions-setup-cmake@v2
      with:
        cmake-version: ${{ env.CMAKE_VERSION }}

    - name: Setup Android NDK (for JNI build)
      uses: nttld/setup-ndk@v1
      with:
        ndk-version: ${{ env.ANDROID_NDK_VERSION }}
        add-to-path: true

    - name: Cache CMake build
      uses: actions/cache@v4
      with:
        path: android-build-${{ matrix.android_abi }}
        key: ${{ runner.os }}-cmake-shared-${{ matrix.android_abi }}-${{ hashFiles('CMakeLists.txt', 'src/**/*.c', 'src/**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-cmake-shared-${{ matrix.android_abi }}-

    - name: Configure build environment
      run: |
        echo "NDK_HOME=$ANDROID_NDK_ROOT" >> $GITHUB_ENV
        echo "ANDROID_NDK_HOME=$ANDROID_NDK_ROOT" >> $GITHUB_ENV
        echo "CMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_ROOT/build/cmake/android.toolchain.cmake" >> $GITHUB_ENV

    - name: Create build directory
      run: |
        mkdir -p android-build-${{ matrix.android_abi }}
        cd android-build-${{ matrix.android_abi }}

    - name: Configure CMake for Android (Shared Library)
      run: |
        cd android-build-${{ matrix.android_abi }}
        # Build NNG as shared library (.so)
        # This creates libnng.so with pure NNG C API (no JNI)
        # Can be used directly by Unity via P/Invoke
        # See: docs/PROJECT_ARTIFACTS_DESIGN.md
        cmake \
          -DCMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE \
          -DANDROID_ABI=${{ matrix.android_abi }} \
          -DANDROID_PLATFORM=android-${{ env.ANDROID_MIN_SDK }} \
          -DANDROID_STL=${{ env.ANDROID_STL }} \
          -DCMAKE_BUILD_TYPE=Release \
          -DNNG_TESTS=OFF \
          -DNNG_TOOLS=OFF \
          -DNNG_ENABLE_STATS=ON \
          -DBUILD_SHARED_LIBS=ON \
          ..

    - name: Build NNG
      run: |
        cd android-build-${{ matrix.android_abi }}
        cmake --build . --config Release --parallel $(nproc)

    - name: Verify build output
      run: |
        cd android-build-${{ matrix.android_abi }}
        ls -la
        find . -name "*.so" -type f
        if [ ! -f "libnng.so" ]; then
          echo "Error: libnng.so not found!"
          exit 1
        fi
        file libnng.so
        # List exported symbols
        readelf -sW libnng.so | grep -E "nng_pair|nng_send|nng_recv|nng_listen|nng_dial" | head -20

    - name: Prepare JNI build environment
      run: |
        # Verify required files exist
        if [ ! -f "jni-source/jni/com_nng_android_NngWrapper.cpp" ]; then
          echo "Error: JNI source file not found!"
          ls -la jni-source/jni/ || echo "jni-source/jni/ directory not found"
          exit 1
        fi
        
        if [ ! -f "android-build-${{ matrix.android_abi }}/libnng.so" ]; then
          echo "Error: libnng.so not found!"
          ls -la android-build-${{ matrix.android_abi }}/
          exit 1
        fi
        
        # Create directory structure for ndk-build
        mkdir -p jni-build/jni
        mkdir -p jni-build/libs/${{ matrix.android_abi }}
        mkdir -p jni-build/nng-include
        
        # Copy JNI source files
        cp jni-source/jni/com_nng_android_NngWrapper.cpp jni-build/jni/
        cp jni-source/jni/com_nng_android_NngWrapper.h jni-build/jni/
        
        # Copy NNG headers (from the checked out NNG repository)
        echo "Checking NNG repository structure:"
        ls -la
        
        if [ ! -d "include" ]; then
          echo "Error: NNG include directory not found!"
          echo "Available directories:"
          ls -la
          exit 1
        fi
        
        echo "NNG include directory contents:"
        ls -la include/
        
        # Verify main NNG header exists
        if [ ! -f "include/nng/nng.h" ]; then
          echo "Error: Main NNG header (nng/nng.h) not found!"
          find include -name "*.h" | head -10
          exit 1
        fi
        
        cp -r include/* jni-build/nng-include/
        
        echo "Copied NNG headers to jni-build/nng-include/:"
        ls -la jni-build/nng-include/
        
        # Copy the built libnng.so to multiple locations for ndk-build
        cp android-build-${{ matrix.android_abi }}/libnng.so jni-build/libs/${{ matrix.android_abi }}/
        # Also copy to jni directory for easier access
        cp android-build-${{ matrix.android_abi }}/libnng.so jni-build/jni/
        
        echo "JNI build environment prepared successfully"

    - name: Create Android.mk for JNI build
      run: |
        cat > jni-build/jni/Android.mk << 'EOF'
        LOCAL_PATH := $(call my-dir)
        
        # Import prebuilt libnng.so
        include $(CLEAR_VARS)
        LOCAL_MODULE := nng
        LOCAL_SRC_FILES := libnng.so
        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/../nng-include
        include $(PREBUILT_SHARED_LIBRARY)
        
        # Build JNI wrapper
        include $(CLEAR_VARS)
        LOCAL_MODULE := nng_jni
        LOCAL_SRC_FILES := com_nng_android_NngWrapper.cpp
        LOCAL_C_INCLUDES := $(LOCAL_PATH)/../nng-include
        LOCAL_SHARED_LIBRARIES := nng
        LOCAL_LDLIBS := -llog -landroid
        LOCAL_CPPFLAGS := -std=c++11 -fexceptions
        include $(BUILD_SHARED_LIBRARY)
        EOF

    - name: Create Application.mk for JNI build
      run: |
        cat > jni-build/jni/Application.mk << 'EOF'
        APP_ABI := ${{ matrix.android_abi }}
        APP_PLATFORM := android-${{ env.ANDROID_MIN_SDK }}
        APP_STL := ${{ env.ANDROID_STL }}
        APP_OPTIM := release
        APP_CPPFLAGS := -std=c++11 -fexceptions
        EOF

    - name: Build JNI wrapper
      run: |
        cd jni-build
        echo "Starting JNI build with ndk-build..."
        echo "NDK_ROOT: $ANDROID_NDK_ROOT"
        echo "Current directory: $(pwd)"
        
        echo "Directory structure before build:"
        find . -name "*.so" -o -name "*.mk" | sort
        
        echo "JNI directory contents:"
        ls -la jni/
        
        echo "Libs directory structure:"
        ls -la libs/ 2>/dev/null || echo "libs directory not found"
        ls -la libs/${{ matrix.android_abi }}/ 2>/dev/null || echo "Architecture-specific libs directory not found"
        
        # Verify libnng.so exists at expected location
        if [ ! -f "libs/${{ matrix.android_abi }}/libnng.so" ]; then
          echo "Error: libnng.so not found at expected location!"
          echo "Expected: libs/${{ matrix.android_abi }}/libnng.so"
          find . -name "libnng.so" -type f
          exit 1
        fi
        
        # Run ndk-build with error handling
        if ! ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=./jni/Application.mk APP_BUILD_SCRIPT=./jni/Android.mk -j$(nproc); then
          echo "Error: ndk-build failed!"
          echo "Build log:"
          cat obj/local/${{ matrix.android_abi }}/objs/nng_jni/*.o.d 2>/dev/null || echo "No build log found"
          exit 1
        fi
        
        echo "JNI build completed successfully"

    - name: Verify JNI build output
      run: |
        cd jni-build
        ls -la libs/${{ matrix.android_abi }}/
        if [ ! -f "libs/${{ matrix.android_abi }}/libnng_jni.so" ]; then
          echo "Error: libnng_jni.so not found!"
          exit 1
        fi
        file libs/${{ matrix.android_abi }}/libnng_jni.so
        # Check JNI symbols
        readelf -sW libs/${{ matrix.android_abi }}/libnng_jni.so | grep -E "Java_com_nng_android_NngWrapper" | head -10

    - name: Prepare complete artifacts (shared + JNI)
      run: |
        mkdir -p complete-artifacts/${{ matrix.android_abi }}
        # Copy both libraries
        cp android-build-${{ matrix.android_abi }}/libnng.so complete-artifacts/${{ matrix.android_abi }}/
        cp jni-build/libs/${{ matrix.android_abi }}/libnng_jni.so complete-artifacts/${{ matrix.android_abi }}/

    - name: Upload temp complete libraries for packaging
      uses: actions/upload-artifact@v4
      with:
        name: temp-complete-${{ matrix.android_abi }}
        path: complete-artifacts/${{ matrix.android_abi }}/
        retention-days: 1

  package-artifacts:
    needs: build-android-shared
    runs-on: ubuntu-latest
    if: always() && (needs.build-android-shared.result == 'success')

    steps:
    - name: Download all architecture artifacts for packaging
      uses: actions/download-artifact@v4
      with:
        pattern: temp-complete-*
        path: temp-artifacts

    - name: Package all Android builds
      run: |
        mkdir -p libnng-android-complete
        
        echo "Available temp artifacts:"
        ls -la temp-artifacts/
        
        for abi in arm64-v8a armeabi-v7a x86_64 x86; do
          echo "Processing architecture: $abi"
          
          # Create architecture directory
          mkdir -p "libnng-android-complete/$abi"
          
          # Copy both libraries from temp artifacts
          if [ -d "temp-artifacts/temp-complete-$abi" ]; then
            echo "Found artifacts for $abi:"
            ls -la "temp-artifacts/temp-complete-$abi/"
            cp temp-artifacts/temp-complete-$abi/* "libnng-android-complete/$abi/"
            
            # Verify both libraries are present
            if [ ! -f "libnng-android-complete/$abi/libnng.so" ]; then
              echo "Warning: libnng.so missing for $abi"
            fi
            if [ ! -f "libnng-android-complete/$abi/libnng_jni.so" ]; then
              echo "Warning: libnng_jni.so missing for $abi"
            fi
          else
            echo "Warning: No artifacts found for $abi"
          fi
        done
        
        echo "Final package contents:"
        find libnng-android-complete -type f -name "*.so" | sort
        
        # Create a comprehensive README
        cat > libnng-android-complete/README.md << EOF
        # NNG Android Libraries - Complete Package
        
        This package contains both pure NNG shared libraries and JNI wrapper libraries for Android.
        
        ## Contents
        
        Each architecture directory contains:
        - \`libnng.so\`: Pure NNG shared library (C API)
        - \`libnng_jni.so\`: JNI wrapper library (Java API)
        
        ## Use Cases
        
        ### Unity (C# P/Invoke) - Use libnng.so only
        Place libnng.so in Assets/Plugins/Android/libs/<arch>/ and use P/Invoke:
        \`\`\`csharp
        [DllImport("nng")]
        public static extern int nng_pair0_open(out IntPtr socket);
        \`\`\`
        
        ### Android Java App - Use both libraries
        1. Place both libnng.so and libnng_jni.so in your Android project's jniLibs/<arch>/ directory
        2. Load the JNI wrapper in your Java code:
        \`\`\`java
        static {
            System.loadLibrary("nng");      // Load libnng.so first
            System.loadLibrary("nng_jni");  // Then load libnng_jni.so
        }
        \`\`\`
        3. Use the NngWrapper class (Java class not included in this package)
        
        ### React Native - Use both libraries
        Similar to Android Java, place both .so files in android/app/src/main/jniLibs/<arch>/
        
        ## Architecture Support
        - arm64-v8a: 64-bit ARM (recommended for modern devices)
        - armeabi-v7a: 32-bit ARM (legacy devices)
        - x86_64: 64-bit x86 (emulators)
        - x86: 32-bit x86 (legacy emulators)
        
        ## Build Information
        - Built with Android NDK ${{ env.ANDROID_NDK_VERSION }}
        - Target API Level: ${{ env.ANDROID_MIN_SDK }} 
        - STL: ${{ env.ANDROID_STL }}
        - Build Type: Release
        - NNG Version: ${{ github.event.inputs.version_tag || env.NNG_VERSION }}
        
        ## JNI Wrapper API
        The JNI wrapper provides these main functions:
        - Socket creation: nngPair0Open, nngReq0Open, nngPub0Open, etc.
        - Communication: nngSend, nngRecv, nngListen, nngDial
        - Configuration: nngSetRecvTimeout, nngSetSendTimeout
        - Utilities: nngClose, nngStrerror, nngVersion
        
        Generated on: \$(date)
        Commit: ${{ github.sha }}
        EOF
        
        # Create package name with version if specified
        package_name="libnng-android-complete"
        if [ -n "${{ github.event.inputs.version_tag }}" ]; then
          package_name="libnng-android-complete-${{ github.event.inputs.version_tag }}"
        fi
        tar -czf "$package_name.tar.gz" libnng-android-complete/

    - name: Upload combined package
      uses: actions/upload-artifact@v4
      with:
        name: libnng-android-complete-all-architectures${{ github.event.inputs.version_tag && format('-{0}', github.event.inputs.version_tag) || '' }}
        path: |
          libnng-android-complete*.tar.gz
          libnng-android-complete/
        retention-days: 90

    - name: Clean up temp artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: temp-complete-*
        failOnError: false

  build-aar:
    needs: build-android-shared
    runs-on: ubuntu-latest
    if: always() && (needs.build-android-shared.result == 'success')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Set Android environment variables
      run: |
        echo "ANDROID_HOME=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
        echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> $GITHUB_ENV

    - name: Install required SDK components
      run: |
        sdkmanager --install "platforms;android-35" "build-tools;35.0.0"

    - name: Download all native libraries
      uses: actions/download-artifact@v4
      with:
        pattern: temp-complete-*
        path: temp-artifacts

    - name: Setup Android library native libraries
      run: |
        echo "Setting up native libraries for AAR..."
        
        # Create jniLibs directories
        mkdir -p android-library/src/main/jniLibs/{arm64-v8a,armeabi-v7a,x86_64,x86}
        
        # Copy native libraries to jniLibs
        for abi in arm64-v8a armeabi-v7a x86_64 x86; do
          if [ -d "temp-artifacts/temp-complete-$abi" ]; then
            echo "Copying libraries for $abi..."
            cp temp-artifacts/temp-complete-$abi/*.so android-library/src/main/jniLibs/$abi/
            ls -la android-library/src/main/jniLibs/$abi/
          else
            echo "Warning: No libraries found for $abi"
          fi
        done
        
        echo "Final jniLibs structure:"
        find android-library/src/main/jniLibs -name "*.so" | sort

    - name: Add libc++_shared.so to prevent runtime errors
      run: |
        echo "Adding libc++_shared.so for all architectures..."
        
        # Find Android NDK path
        NDK_PATH=$(find $ANDROID_SDK_ROOT -name "ndk" -type d | head -1)
        if [ -z "$NDK_PATH" ]; then
          echo "Error: NDK not found in Android SDK"
          exit 1
        fi
        
        # Find the latest NDK version
        NDK_VERSION=$(ls $NDK_PATH | sort -V | tail -1)
        NDK_ROOT="$NDK_PATH/$NDK_VERSION"
        
        echo "Using NDK: $NDK_ROOT"
        
        # Copy libc++_shared.so for each architecture
        for abi in arm64-v8a armeabi-v7a x86_64 x86; do
          LIBCPP_PATH="$NDK_ROOT/sources/cxx-stl/llvm-libc++/libs/$abi/libc++_shared.so"
          if [ -f "$LIBCPP_PATH" ]; then
            echo "Copying libc++_shared.so for $abi..."
            cp "$LIBCPP_PATH" android-library/src/main/jniLibs/$abi/
          else
            echo "Warning: libc++_shared.so not found for $abi at $LIBCPP_PATH"
          fi
        done
        
        echo "Updated jniLibs structure with libc++_shared.so:"
        find android-library/src/main/jniLibs -name "*.so" | sort

    - name: Create gradle.properties
      run: |
        echo "Creating gradle.properties with required settings..."
        cat > gradle.properties << 'EOF'
        # Project-wide Gradle settings.
        # IDE (e.g. Android Studio) users:
        # Gradle settings configured through the IDE *will override*
        # any settings specified in this file.
        # For more details on how to configure your build environment visit
        # http://www.gradle.org/docs/current/userguide/build_environment.html

        # Specifies the JVM arguments used for the daemon process.
        # The setting is particularly useful for tweaking memory settings.
        org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8

        # When configured, Gradle will run in incubating parallel mode.
        # This option should only be used with decoupled projects. More details, visit
        # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
        # org.gradle.parallel=true

        # AndroidX package structure to make it clearer which packages are bundled with the
        # Android operating system, and which are packaged with your app's APK
        # https://developer.android.com/topic/libraries/support-library/androidx-rn
        android.useAndroidX=true

        # Enables namespacing of each library's R class so that its R class includes only the
        # resources declared in the library itself and none from the library's dependencies,
        # thereby reducing the size of the R class for that library
        android.nonTransitiveRClass=true
        EOF

    - name: Fix settings.gradle repository mode
      run: |
        echo "Fixing settings.gradle repository mode..."
        sed -i 's/repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)/repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)/g' settings.gradle
        echo "Updated settings.gradle:"
        cat settings.gradle

    - name: Setup Gradle Wrapper
      run: |
        echo "Setting up Gradle Wrapper..."
        # Create gradle wrapper directory if it doesn't exist
        mkdir -p gradle/wrapper
        
        # Use gradle to generate wrapper if gradlew doesn't exist or gradle-wrapper.jar is missing
        if [ ! -f "./gradlew" ] || [ ! -f "gradle/wrapper/gradle-wrapper.jar" ]; then
          echo "Generating Gradle Wrapper..."
          # Install gradle temporarily to generate wrapper
          if ! command -v gradle &> /dev/null; then
            echo "Installing Gradle..."
            wget -q https://services.gradle.org/distributions/gradle-8.7-bin.zip
            unzip -q gradle-8.7-bin.zip
            export PATH=$PWD/gradle-8.7/bin:$PATH
          fi
          gradle wrapper --gradle-version=8.7
        fi
        
        # Make gradlew executable
        chmod +x ./gradlew
        
        # Verify wrapper works
        ./gradlew --version

    - name: Build AAR
      run: |
        echo "Building AAR with Gradle..."
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "JAVA_HOME: $JAVA_HOME"
        ./gradlew android-library:assembleRelease --stacktrace --info

    - name: Verify AAR build
      run: |
        echo "Verifying AAR build output..."
        ls -la android-library/build/outputs/aar/
        
        # Check AAR contents
        if [ -f android-library/build/outputs/aar/android-library-release.aar ]; then
          echo "AAR file created successfully"
          unzip -l android-library/build/outputs/aar/android-library-release.aar
        else
          echo "Error: AAR file not found!"
          exit 1
        fi

    - name: Upload AAR
      uses: actions/upload-artifact@v4
      with:
        name: nng-android-library-aar${{ github.event.inputs.version_tag && format('-{0}', github.event.inputs.version_tag) || '' }}
        path: android-library/build/outputs/aar/android-library-release.aar
        retention-days: 90

    - name: Clean up temp artifacts (if not already cleaned)
      uses: geekyeggo/delete-artifact@v5
      with:
        name: temp-complete-*
        failOnError: false